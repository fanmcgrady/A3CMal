# encoding=utf-8
"""
Malware Environment for attacking MalConv model
专门用于攻击MalConv模型的环境
"""
import csv
import hashlib
import os
import random
from collections import OrderedDict

import gym
from gym import spaces
import numpy as np

from action import manipulate2 as manipulate2
from tools import interface_malconv as interface
from state.state_malconv import FeatureExtractMalConv

ACTION_LOOKUP = {i: act for i, act in enumerate(
    manipulate2.ACTION_TABLE.keys())}


class MalwareEnvMalConv(gym.Env):
    """
    攻击MalConv模型的强化学习环境
    
    主要区别：
    1. 使用MalConv进行分类（二分类）
    2. 观察空间是原始字节序列而非手工特征
    3. 目标是从'1'(恶意)变成'0'(良性)
    """
    metadata = {'render.modes': ['human']}

    def __init__(self, sha256list, random_sample=True, maxturns=60, cache=True, test=False):
        self.test = test
        print("[Using MalConv env {}]".format('malware-malconv-test-v0' if self.test else 'malware-malconv-v0'))
        
        # 使用MalConv的分类函数
        self.label_function = interface.get_label_local
        self.confidence_function = interface.get_confidence

        self.total_turn = 0
        self.test_turn = 0
        self.episode = -1
        self.cache = cache
        self.available_sha256 = sha256list
        self.action_space = spaces.Discrete(len(ACTION_LOOKUP))
        self.maxturns = maxturns
        self.random_sample = random_sample
        self.sample_iteration_index = 0
        
        # MalConv特征提取器
        self.feature_extractor = FeatureExtractMalConv()
        
        # 观察空间：1MB的字节序列
        self.observation_space = spaces.Box(
            low=0, 
            high=256, 
            shape=(1, self.feature_extractor.maxlen), 
            dtype=np.int16
        )

        self.samples_path = os.path.join(
            os.path.dirname(
                os.path.dirname(
                    os.path.dirname(
                        os.path.abspath(__file__)))), "../../Dataset/")

        self.history = OrderedDict()
        self.current_reward = 0

        self.samples = {}

        # 缓存样本到内存
        if self.cache:
            print("Caching samples to memory...")
            for i, sha256 in enumerate(self.available_sha256):
                try:
                    self.samples[sha256] = interface.fetch_file(sha256, self.test)
                except Exception as e:
                    print(f"Failed fetching file {sha256}: {e}")
                    continue
            print(f"✓ Cached {len(self.samples)} samples")

        # 读出原始标签（对MalConv都是'1'）
        self.label_map = interface.get_original_label()

        self.reset()

    def step(self, action_index):
        """
        执行一个动作
        
        Args:
            action_index: 动作索引
            
        Returns:
            observation: 新的状态
            reward: 奖励
            done: 是否结束
            info: 额外信息
        """
        self.total_turn += 1
        self.turns += 1
        
        # 执行动作修改PE文件
        self._take_action(action_index)
        
        # 获取奖励
        try:
            # MalConv分类
            self.label = self.label_function(self.bytez)
            self.confidence = self.confidence_function(self.bytez)
            
            # 提取新状态
            self.observation_space = self.feature_extractor.get_state(self.bytez)
            
        except Exception as e:
            print(f"Failed to classify file {self.sha256}: {e}")
            episode_over = True
            self.current_reward = 0.0
        else:
            # 检查是否成功免杀
            original_label = self.label_map[self.sha256]
            
            # MalConv二分类免杀：从'1'(恶意)变成'0'(良性)
            if self.label == '0' and original_label == '1':
                # 成功！
                self.current_reward = 10
                episode_over = True
                self.history[self.sha256]['evaded'] = True
                self.history[self.sha256]['final_confidence'] = self.confidence
                
                print(f"✓ Success: {self.sha256}")
                print(f"  Actions: {self.history[self.sha256]['actions']}")
                print(f"  Confidence: {self.confidence:.4f} (< 0.5 = benign)")

            elif self.turns >= self.maxturns:
                # 超过最大次数，失败
                self.current_reward = 0.0
                episode_over = True
                print(f"✗ Failure: {self.sha256}")
                print(f"  Actions: {self.history[self.sha256]['actions']}")
                print(f"  Final confidence: {self.confidence:.4f}")
            else:
                # 继续尝试
                self.current_reward = 0.0
                episode_over = False

        return self.observation_space, self.current_reward, episode_over, {
            'confidence': getattr(self, 'confidence', None)
        }

    def _take_action(self, action_index):
        """执行动作"""
        assert action_index < len(ACTION_LOOKUP)
        action = ACTION_LOOKUP[action_index]
        
        self.history[self.sha256]['actions'].append(action)
        self.bytez = bytes(manipulate2.modify_without_breaking(self.bytez, [action]))

    def reset(self):
        """
        重置环境，选择新样本
        
        Returns:
            observation: 初始状态
        """
        self.turns = 0
        self.episode += 1
        
        while True:
            # 选择样本
            if self.random_sample:
                self.sha256 = random.choice(self.available_sha256)
            else:
                self.sha256 = self.available_sha256[self.sample_iteration_index % len(self.available_sha256)]
                self.sample_iteration_index += 1

            self.history[self.sha256] = {
                'actions': [], 
                'evaded': False,
                'initial_confidence': None,
                'final_confidence': None
            }

            # 加载样本
            if self.cache:
                self.bytez = self.samples[self.sha256]
            else:
                try:
                    self.bytez = interface.fetch_file(self.sha256, self.test)
                except:
                    print(f"Failed fetching file {self.sha256}")
                    continue

            # 检查原始预测
            predict_label = self.label_function(self.bytez)
            initial_confidence = self.confidence_function(self.bytez)
            self.history[self.sha256]['initial_confidence'] = initial_confidence
            
            # 确保原始样本被正确分类为恶意
            if predict_label != self.label_map[self.sha256]:
                # 跳过误分类的样本
                continue

            self.tips = ' ' if not self.test else 'test '

            if self.episode > 0:
                print("="*80)
                print(f"{self.tips}Episode {self.episode} - Selected: {self.sha256}")
                print(f"  Initial confidence: {initial_confidence:.4f}")
                print("="*80)

            break

        # 提取初始状态
        self.observation_space = self.feature_extractor.get_state(self.bytez)

        return self.observation_space


# 注册环境
from gym.envs.registration import register

register(
    id='malware-malconv-v0',
    entry_point='env.malware.malware_env_malconv:MalwareEnvMalConv',
    kwargs={'sha256list': interface.get_available_sha256(test=False)}
)

register(
    id='malware-malconv-test-v0',
    entry_point='env.malware.malware_env_malconv:MalwareEnvMalConv',
    kwargs={'sha256list': interface.get_available_sha256(test=True), 'test': True}
)


if __name__ == '__main__':
    print("Testing MalwareEnvMalConv...")
    
    # 创建环境
    env = gym.make('malware-malconv-v0')
    
    print(f"\nEnvironment created:")
    print(f"  Observation space: {env.observation_space}")
    print(f"  Action space: {env.action_space}")
    print(f"  Max turns: {env.maxturns}")
    
    # 测试一个episode
    print("\nTesting one episode...")
    obs = env.reset()
    print(f"  Initial observation shape: {obs.shape}")
    
    # 执行几个随机动作
    for i in range(3):
        action = env.action_space.sample()
        obs, reward, done, info = env.step(action)
        print(f"  Step {i+1}: action={ACTION_LOOKUP[action]}, reward={reward}, done={done}, confidence={info.get('confidence')}")
        if done:
            break
    
    print("\n✓ MalwareEnvMalConv test passed!")

